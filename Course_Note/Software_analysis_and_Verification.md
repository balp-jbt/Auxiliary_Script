# 软件分析与验证

## 1 命题逻辑和一阶逻辑

### 1.1 语法

 **命题逻辑符号集**

|    类型    |           全部符号 / 符号举例            |
| :--------: | :--------------------------------------: |
|  真值符号  |              $\top,\;\bot$               |
| 逻辑连结词 | $\neg,\;\and,\or,\;\to\;\leftrightarrow$ |
|  命题变元  |            $a,\;b,\;c\cdots$             |

原子命题/原子公式：命题变元+真值符号

文字：原子公式及其否定

**一阶逻辑符号集**

|   类型2    |           全部符号 / 符号举例            |
| :--------: | :--------------------------------------: |
|  真值符号  |              $\top,\;\bot$               |
| 逻辑连结词 | $\neg,\;\and,\or,\;\to\;\leftrightarrow$ |
|  量词符号  |           $\forall,\;\exists$            |
|  变元符号  |            $x,\;y,\;z\cdots$             |
|  常元符号  |            $a,\;b,\;c\cdots$             |
|  函数符号  |            $f,\;g,\;h\cdots$             |
|  谓词符号  |            $p,\;q,\;r\cdots$             |

非逻辑符号：常元符号、函数符号、谓词符号  （逻辑符号：其余符号）

项：变元符号+常元符号+参数全为项的函数

原子公式：真值符号+参数全为项的谓词

文字：原子公式及其否定

其他概念：量词辖域，约束变元，自由变元，开公式，闭公式

### 1.2 语义

**命题逻辑**

变元赋值(真值指派)$\rho$，：将变元集$\{a,\;b,\;c\cdots\}$映射到真值集合$\{\top,\;\bot\}$的函数

公式的取值：不同赋值$\rho$下，命题逻辑公式$F$的取值$[[F]]_\rho$可以进行递归定义

永真式，可满足式和不可满足式：类似"对于任意赋值$\rho$或存在赋值$\rho$....."可以定义

永真式：$\models F$

语义蕴含/有效推论：对于两个公式$F,G$和任意的赋值$\rho$，只要$[[F]]_\rho$为真则$[[G]]_\rho$为真，则称$F$语义蕴含$G$，或$G$是$F$的有效推论，记作$F\Rightarrow G$

语义等价：对于两个公式$F,G$，若$F\Rightarrow G$且$G \Rightarrow F$则称$F$和$G$语义等价，记作$F\Leftrightarrow G$

**一阶逻辑**

解释：$\mathcal{M}=(\mathcal{D,\;I})$ ​

论域：$\mathcal{D}$，包含所有希望讨论的元素(变元、常元的取值范围)

解释函数: $\mathcal{I}$，将每个常元映射为$\mathcal{D}$中的一个元素；为每个n元函数符号$f$，谓词符号$p$分别指定$\mathcal{D}$上的n元函数或n元关系

赋值：$\rho$，将每个自由变元映射到$\mathcal{D}$​中的元素

赋值变体：$\rho[x\mapsto c]$ 除$x$赋值为$c$外其余与赋值$\rho$一致

对项求值：项$t$在解释$\mathcal{M}$和赋值$\rho$下的取值可以递归定义，其中常元取值由$\mathcal{I}$指定，变元取值由赋值$\rho$指定

对公式求值：基于对项求值(其结果为论域中某个元素)的结果，可类比命题逻辑定义对公式求值

可满足式 / 永真式：类似“对于任意解释$\mathcal{M}$任意赋值$\rho$ ...”可以定义

永真式：$\models \varphi$​

语义蕴含 / 有效推论：类比命题逻辑，类似“对于任意解释$\mathcal{M}$任意赋值$\rho$....”可以定义

### 1.3 证明系统

命题逻辑: 相继式演算系统$S_{PL}$, 可靠完备，可判定

一阶逻辑：相继式演算系统$S_{FOL}$，可靠完备，半可判定

相继式：形如
$$
F_1, F_2,\cdots F_m \vdash G_1,G_2\cdots G_n
$$
其中$F_1, F_2,\cdots F_m$是前件，$G_1,G_2\cdots G_n$是后件

其含义：前件是假设，后件是推论，前件均成立后，后件至少有一成立，即：
$$
F_1 \and F_2\and \cdots F_m \to G_1 \or G_2 \cdots G_n
$$
将想要证明的公式作为根节点，写在最下，依次根据推理规则进行推导，期间有可能有多个分支，直至最终证明完毕

命题逻辑证明规则：左/右 蕴含/否定/析取/合取， 切规则

一阶逻辑证明规则：在命题逻辑规则上添加左/右 存在/全称规则；**[存疑] 量词在推导时优先应用左存在和右全称**

<font color=red>**[Qusetion] 量词的推导规则如何证明正确性**</font>



## 2 一阶理论

### 2.1 定义

一阶理论：$\mathcal{T}$=$(\Sigma,\; \mathcal{A})$

签名：非逻辑符号集$\Sigma$, 即对出现的非逻辑符号进行限制

公理集：一组定义在$\Sigma$上的闭公式$\mathcal{A}$，即说明了非逻辑符号含义

一阶理论片段：对一阶理论公式再次作限制，如不允许量词出现等

### 2.2 等式理论

$\Sigma_E$：签名集$\{=,a,b,c,\cdots,f,g,h,\cdots, p,q,r,\cdots\}$ 即引入了$=$谓词符号，对其余常数，函数，谓词符号没有限制

$\mathcal{A}_E$：公理集合$\mathcal{A}$，引入"="的含义

等式和未解释函数理论：通过"="谓词，构建未解释函数消除所有其他谓词

可判定性：$\Tau_E$​是不可判定的，但其无量词片段是可判定的



## 3 程序语义

### 3.1 相关概念

1. 指称语义：程序执行效果对应数学对象，更加关心执行效果
2. 操作语义：使用抽象状态机描述程序执行产生的状态改变，更适用于描述程序的执行过程
3. 关系语义：给予关系定义程序语言的语义，更适用于程序自动验证
4. 公理语义：将语义性质表示为命题，采用数理逻辑方法研究

### 3.2 表达式语义

程序的状态：$State: \; Var \to Z$，即对程序变元的一组赋值(注意以下未说明不区分赋值和状态)

状态全集：$\mathcal{S}$

算数表达式的语义: 区分于结果为真值得布尔表达式，对$AExp$, 其语义函数为$[\cdot]_.^A:\;\; AExp \to (S\to Z)$

算数表达式的取值：可递归定义算术表达式$e$在状态$s$下的值$[[e]]_s^A$

布尔表达式的语义函数：$[\cdot]_.^B:\;\;BExp\to \;(S\to B)$​

布尔表达式的取值：可递归定义布尔表达式$e$在状态$s$下的值$[[e]]_s^B$

### 3.3 程序语句语义

(补充)关系的组合:$R_1, R_2$是定义在同一个集合$X$上的二元关系，$R_1$和$R_2$的组合关系定义为
$$
R_1 \circ R_2 = \{(a, b)\;|\; \exist c \in X, s.t. (a, c) \in R_1,\;(c, b) \in R_2\}
$$
基本思想：$[[st]]=\{(s,s')|\text{从}s\text{出发执行}st\text{可能会得到}s'\}$，语义为所有执行情况的状态对，$s$为前状态，$s'$为后状态，这里$[[st]]\sube \mathcal{S} \times \mathcal{S}$，是一个二元关系

语义等价： 对于任意状态$s\text{和}\; s'$，(s, s')\in [st_1]$当且仅当$(s, s')\in [st_2]$从，则称$st_1$与$​st_2$语义等价

空语句语义：
$$
[[\textbf{skip}]]=\{(s,s)|\;s\in \mathcal{S} \}
$$
赋值语句语义：
$$
[[x:=e]]=\{(s,s')|\;s'= s[x \mapsto[[e]]_s] \}
$$
分支语句语义：
$$
[[\textbf{if}(p)\{st_1\}\; \textbf{else} \{st_2\}]]=\left \{(s, s')\Bigg |\; \begin{array} \;[[p]]_s=true \text{且} (s,s')\in [[st_1] \\ [[p]]_s = false \text{且} (s, s') \in [[st_2]]\end{array} \right \}
$$
顺序语句语义：
$$
\begin{align*}
[[st_1;st_2]] &= [[st_1]] \circ [[st_2]] \\
&= \{(s,s')|\;\text{存在}s''\text{使得}(s,s'')\in[[st_1]],[[s'', s']]\in [[st_2]]\}
\end{align*}
$$
循环语句语义：
$$
[[\textbf{while}(p)\{st\}]]= \left \{ (s, s') \Bigg |\begin{align*}
& \text{存在一个整数和一组状态序列}t_0,t_1,\cdots\cdots,t_n,\text{其中}t_0=s，t_n=s',\text{使得}:\\
& \text{(1)循环条件成立,即}[[p]]t_i=true,\;0 \leq i \leq n \\
& \text{(2)循环体语句执行效果,即}(t_i,t_{i+1}) \in [[st]], \;0 \leq i \leq n \\
& \text{(3)退出循环条件成立,即}[[p]]_{t_n}=false
\end{align*} \right \}
$$


## 4 霍尔逻辑

### 4.1 Hoare Triple

1. 形如下式：$st$为程序，描述从任何满足$\varphi$的前状态执行$st$，<font color=red>若$st$终止</font>，则后状态必然满足$\psi$、
   $$
   \{\varphi\}\;\;st\;\;\{\psi\}
   $$

2. **后像(post-image, equivlent to forward-image)** $R$为定义在$X$上的二元关系，$Y \subseteq X$是$X$的一个子集，则$Y$关于$R$的后像定义为
   $$
   post(Y,R)::=\{x\in X\;|\; \exists y \in Y s.t. (y,x) \in R \}
   $$

   * 语义解释：从$Y$状态集合出发，经由$st$语句(集合)，可达的状态集合

3. **有效的霍尔三元组** 

若$post(\{\varphi, [st]\}) \subseteq \{\psi\}$，则记作 $st\models(\varphi, \psi)$，称$st$满足规约$(\phi, \psi)$，也称霍尔三元组$\{\phi\}st\{\psi\}$是有效式，记作:
$$
\models\{\phi\}st\{\psi\}
$$

### 4.2 霍尔证明系统

> 推导有效霍尔三元组

1. 推导树(derivatin tree)
   * 每个节点都是霍尔三元组，中间节点是某条规则的结论，子节点是规则的前提
2. 可推导
   * 存在一颗为根的推导树，则称其为可推导
3. 赋值语句的可靠性(逆向推导)
4. 前提加强规则(前状态语义蕴含式可以作为新的前状态)
5. 结论弱化规则(前提加强规则的反向
6. 霍尔证明系统是可靠的，相对完备的
